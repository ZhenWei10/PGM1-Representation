phi = struct('var', [3 1 2], 'card', [2 2 2], 'val', ones(1, 8)); %Several accessorsphi.var  % Access the values of variables headers.phi.val(6) % Access the factor entry of the 6th row.%card means cardinality, i.e. a measure of the "number of elements of the set". equal to length(levels(factor_x)) in R. addpath("/Users/zhenwei/Desktop/Probability_graphical_models/Assignment-1") %Access to the general rules of the formation of the data structure (not for any particular data) AssignmentToIndex([2 1 2], [2 2 2])  %Access row index with a factor combination 2,1,2, and cardinality [2,2,2]AssignmentToIndex([1 1 1; 2 1 2; 2 2 1], [2,2,2]) %The input can be a matrix.IndexToAssignment(6, [2 2 2]) %Access to the factor combination value given a row index (row number).IndexToAssignment([6;7;8], [2 2 2]) %The input can be a collumn vector.% -+-----+-----+-----+-------------------+   %  | X_3 | X_1 | X_2 | phi(X_3, X_1, X_2)|% -+-----+-----+-----+-------------------+%  |  1  |  1  |  1  |     phi.val(1)    |% -+-----+-----+-----+-------------------+%  |  2  |  1  |  1  |     phi.val(2)    |% -+-----+-----+-----+-------------------+%  |  1  |  2  |  1  |     phi.val(3)    |% -+-----+-----+-----+-------------------+%  |  2  |  2  |  1  |     phi.val(4)    |% -+-----+-----+-----+-------------------+%  |  1  |  1  |  2  |     phi.val(5)    |% -+-----+-----+-----+-------------------+%  |  2  |  1  |  2  |     phi.val(6)    |% -+-----+-----+-----+-------------------+%  |  1  |  2  |  2  |     phi.val(7)    |% -+-----+-----+-----+-------------------+%  |  2  |  2  |  2  |     phi.val(8)    |% -+-----+-----+-----+-------------------+%Accessors that change the entries / .val field. of a particular factorized dataGetValueOfAssignment(phi, [1 2 1; 2 2 1; 2 1 1]) phi = SetValueOfAssignment(phi, [2 2 1], 6) phi2 = SetValueOfAssignment(phi, [1 2 1; 2 2 1; 2 1 1], [10;11;12]) %Then the following part is the home work validity checkFACTORS.INPUT(1) = struct('var', [1], 'card', [2], 'val', [0.11, 0.89]);FACTORS.INPUT(2) = struct('var', [2, 1], 'card', [2, 2], 'val', [0.59, 0.41, 0.22, 0.78]);FACTORS.INPUT(3) = struct('var', [3, 2], 'card', [2, 2], 'val', [0.39, 0.61, 0.06, 0.94]);FACTORS.PRODUCT = FactorProduct(FACTORS.INPUT(1), FACTORS.INPUT(2));FACTORS.PRODUCT_correct = struct('var', [1, 2], 'card', [2, 2], 'val', [0.0649, 0.1958, 0.0451, 0.6942]);FACTORS.PRODUCT% Factor MarginalizationFACTORS.MARGINALIZATION = FactorMarginalization(FACTORS.INPUT(2), [2]);FACTORS.MARGINALIZATION_correct = struct('var', [1], 'card', [2], 'val', [1 1]); % Observe EvidenceFACTORS.EVIDENCE = ObserveEvidence(FACTORS.INPUT, [2 1; 3 2]);FACTORS.EVIDENCE(1) = struct('var', [1], 'card', [2], 'val', [0.11, 0.89]);FACTORS.EVIDENCE(2) = struct('var', [2, 1], 'card', [2, 2], 'val', [0.59, 0, 0.22, 0]);FACTORS.EVIDENCE(3) = struct('var', [3, 2], 'card', [2, 2], 'val', [0, 0.61, 0, 0]);FACTORS.JOINT = ComputeJointDistribution(FACTORS.INPUT);FACTORS.JOINT_correct = struct('var', [1, 2, 3], 'card', [2, 2, 2], 'val', [0.025311, 0.076362, 0.002706, 0.041652, 0.039589, 0.119438, 0.042394, 0.652548]);FACTORS.MARGINAL = ComputeMarginal([2, 3], FACTORS.INPUT, [1, 2]);FACTORS.MARGINAL_correct = struct('var', [2, 3], 'card', [2, 2], 'val', [0.0858, 0.0468, 0.1342, 0.7332]);